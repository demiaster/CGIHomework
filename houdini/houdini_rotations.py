# import math so we can use cos and sin
import math
# these are generated by houdini and give us access to the current node.
node = hou.pwd()
geo = node.geometry()

# create a 4x4 matrix, passing in 1 creates it as the identity matrix
rotX=hou.Matrix4(1)
rotY=hou.Matrix4(1)
rotZ=hou.Matrix4(1)
# which is the same as calling
# rotX.setToIdentity()
# We can access inputs in different ways this is one
#deg=node.inputConnections()[1]
#d=deg.evalParm('rotX/default1v1')
# however I will use this one.
#hou.parmTuple('/obj/geo1/rotX/value1v').evalAsFloats()[0]
degX=hou.node('/obj/geo1/rotX')
degY=hou.node('/obj/geo1/rotY')
degZ=hou.node('/obj/geo1/rotZ')
# we now need to convert this to radians
theta=math.radians(degX.evalParm('value1v1'))
alpha=math.radians(degY.evalParm('value1v1'))
omega=math.radians(degZ.evalParm('value1v1'))

# pre calculate cos and sin for speed
cosTheta=math.cos(theta)
sinTheta=math.sin(theta)

cosAlpha=math.cos(alpha)
sinAlpha=math.sin(alpha)

cosOmega=math.cos(omega)
sinOmega=math.sin(omega)

# now we set the matrix values note matrix starts at 0,0 and is row / col
rotX.setAt(1,1,cosTheta)
rotX.setAt(1,2,-sinTheta)
rotX.setAt(2,1,sinTheta)
rotX.setAt(2,2,cosTheta)

rotY.setAt(0,0,cosAlpha)
rotY.setAt(2,2,cosAlpha)
rotY.setAt(0,2,sinAlpha)
rotY.setAt(2,0, -sinAlpha)

rotZ.setAt(0,0,cosOmega)
rotZ.setAt(0,1,sinOmega)
rotZ.setAt(1,0, -sinOmega)
rotZ.setAt(1,1, cosOmega)
# now we grab each point in the geometry
for point in geo.points():
    # get the position
    pos = point.position()
    # transform by our matrix
    pos*=rotX
    pos *= rotY
    pos *= rotZ
    # and reset the position
    point.setPosition(pos)
    # Check if the user pressed Escape.
    if hou.updateProgressAndCheckForInterrupt():
        break
